From 02445263e2f533573a935c1bd502d848bbe6bb27 Mon Sep 17 00:00:00 2001
From: Slava Zakharin <szakharin@nvidia.com>
Date: Thu, 26 Jan 2023 14:20:47 -0800
Subject: [PATCH] [flang] Fixed restrictions checking for OpenACC
 loop-associated constructs.

CheckDoConcurrentClauseRestriction and CheckTileClauseRestriction expect
that the construct has associated DoConstruct, while it is not set
when the do-loop has no loop control. The change is to skip the clauses
checks, when the do-loop does not have the loop control.

An alternative fix would be to associate the DoConstruct even when
the do-loop has no loop control and let Check*ClauseRestriction run their
checks, but I am not sure if associating invalid DoConstruct is a good idea.

This fixes failure in Semantics/OpenACC/acc-canonicalization-validity.f90
reported in D142279.

Reviewed By: clementval

Differential Revision: https://reviews.llvm.org/D142652
---
 flang/lib/Semantics/canonicalize-acc.cpp | 41 ++++++++++++------------
 1 file changed, 20 insertions(+), 21 deletions(-)

diff --git a/flang/lib/Semantics/canonicalize-acc.cpp b/flang/lib/Semantics/canonicalize-acc.cpp
index 855f62f53ff8..5afae172cfaa 100644
--- a/flang/lib/Semantics/canonicalize-acc.cpp
+++ b/flang/lib/Semantics/canonicalize-acc.cpp
@@ -127,17 +127,17 @@ private:
     nextIt = it;
     if (++nextIt != block.end()) {
       if (auto *doCons{parser::Unwrap<parser::DoConstruct>(*nextIt)}) {
-        if (doCons->GetLoopControl()) {
-          // move DoConstruct
-          std::get<std::optional<parser::DoConstruct>>(x.t) =
-              std::move(*doCons);
-          nextIt = block.erase(nextIt);
-        } else {
+        if (!doCons->GetLoopControl()) {
           messages_.Say(dir.source,
               "DO loop after the %s directive must have loop control"_err_en_US,
               parser::ToUpperCaseLetters(dir.source.ToString()));
+          return;
         }
 
+        // move DoConstruct
+        std::get<std::optional<parser::DoConstruct>>(x.t) = std::move(*doCons);
+        nextIt = block.erase(nextIt);
+
         CheckDoConcurrentClauseRestriction<parser::OpenACCLoopConstruct,
             parser::AccBeginLoopDirective>(x);
         CheckTileClauseRestriction<parser::OpenACCLoopConstruct,
@@ -173,24 +173,23 @@ private:
     nextIt = it;
     if (++nextIt != block.end()) {
       if (auto *doCons{parser::Unwrap<parser::DoConstruct>(*nextIt)}) {
-        if (doCons->GetLoopControl()) {
-          // move DoConstruct
-          std::get<std::optional<parser::DoConstruct>>(x.t) =
-              std::move(*doCons);
-          nextIt = block.erase(nextIt);
-          // try to match AccEndCombinedDirective
-          if (nextIt != block.end()) {
-            if (auto *endDir{
-                    parser::Unwrap<parser::AccEndCombinedDirective>(*nextIt)}) {
-              std::get<std::optional<parser::AccEndCombinedDirective>>(x.t) =
-                  std::move(*endDir);
-              block.erase(nextIt);
-            }
-          }
-        } else {
+        if (!doCons->GetLoopControl()) {
           messages_.Say(dir.source,
               "DO loop after the %s directive must have loop control"_err_en_US,
               parser::ToUpperCaseLetters(dir.source.ToString()));
+          return;
+        }
+        // move DoConstruct
+        std::get<std::optional<parser::DoConstruct>>(x.t) = std::move(*doCons);
+        nextIt = block.erase(nextIt);
+        // try to match AccEndCombinedDirective
+        if (nextIt != block.end()) {
+          if (auto *endDir{
+                  parser::Unwrap<parser::AccEndCombinedDirective>(*nextIt)}) {
+            std::get<std::optional<parser::AccEndCombinedDirective>>(x.t) =
+                std::move(*endDir);
+            block.erase(nextIt);
+          }
         }
 
         CheckDoConcurrentClauseRestriction<parser::OpenACCCombinedConstruct,
-- 
2.39.2

